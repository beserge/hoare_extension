
Set Warnings "-notation-overridden,-parsing".

From Coq Require Import Bool.Bool.
From Coq Require Import Init.Nat.
From Coq Require Import Arith.Arith.
From Coq Require Import Arith.EqNat.
From Coq Require Import omega.Omega.
From Coq Require Import Lists.List.
From Coq Require Import Strings.String.
Import ListNotations.

(*MAPS *)
Definition total_map (A : Type) := string -> A.

Definition t_empty {A : Type} (v : A) : total_map A :=
  (fun _ => v).



Definition eqb_string (x y : string) : bool :=
  if string_dec x y then true else false.

Definition t_update {A : Type} (m : total_map A)
                    (x : string) (v : A) :=
  fun x' => if eqb_string x x' then v else m x'.

Notation "'_' '!->' v" := (t_empty v)
  (at level 100, right associativity).

Notation "x '!->' v ';' m" := (t_update m x v)
                              (at level 100, v at next level, right associativity).

Definition empty_st := (_ !-> 0).

(*imp*)
Inductive aexp : Type :=
  | ANum (n : nat)
  | AId (x : string)              (* <--- NEW *)
  | APlus (a1 a2 : aexp)
  | AMinus (a1 a2 : aexp)
  | AMult (a1 a2 : aexp).

Inductive bexp : Type :=
  | BTrue
  | BFalse
  | BEq (a1 a2 : aexp)
  | BLe (a1 a2 : aexp)
  | BNot (b : bexp)
  | BAnd (b1 b2 : bexp).


Definition state := total_map nat.

(*
Coercion AId : string >-> aexp.
Coercion ANum : nat >-> aexp.
 *)

Fixpoint aeval (st : state) (a : aexp) : nat :=
  match a with
  | ANum n => n
  | AId x => st x                                (* <--- NEW *)
  | APlus a1 a2 => (aeval st a1) + (aeval st a2)
  | AMinus a1 a2  => (aeval st a1) - (aeval st a2)
  | AMult a1 a2 => (aeval st a1) * (aeval st a2)
  end.

Fixpoint beval (st : state) (b : bexp) : bool :=
  match b with
  | BTrue       => true
  | BFalse      => false
  | BEq a1 a2   => (aeval st a1) =? (aeval st a2)
  | BLe a1 a2   => (aeval st a1) <=? (aeval st a2)
  | BNot b1     => negb (beval st b1)
  | BAnd b1 b2  => andb (beval st b1) (beval st b2)
  end.

Definition bool_to_bexp (b : bool) : bexp :=
  if b then BTrue else BFalse.
(*Coercion bool_to_bexp : bool >-> bexp.*)

Bind Scope imp_scope with aexp.
Bind Scope imp_scope with bexp.
Delimit Scope imp_scope with imp.



Definition W : string := "W".
Definition X : string := "X".
Definition Y : string := "Y".
Definition Z : string := "Z".

Notation "x + y" := (APlus x y) (at level 50, left associativity) : imp_scope.
Notation "x - y" := (AMinus x y) (at level 50, left associativity) : imp_scope.
Notation "x * y" := (AMult x y) (at level 40, left associativity) : imp_scope.
Notation "x <= y" := (BLe x y) (at level 70, no associativity) : imp_scope.
Notation "x = y" := (BEq x y) (at level 70, no associativity) : imp_scope.
Notation "x && y" := (BAnd x y) (at level 40, left associativity) : imp_scope.
Notation "'~' b" := (BNot b) (at level 75, right associativity) : imp_scope.

Inductive com : Type :=
  | CSkip
  | CAss (x : string) (a : aexp)
  | CSeq (c1 c2 : com)
  | CIf (b : bexp) (c1 c2 : com)
  | CWhile (b : bexp) (c : com)
  | CLoop (a : aexp) (c : com).


Bind Scope imp_scope with com.
Notation "'SKIP'" :=
   CSkip : imp_scope.
Notation "x '::=' a" :=
  (CAss x a) (at level 60) : imp_scope.
Notation "c1 ;; c2" :=
  (CSeq c1 c2) (at level 80, right associativity) : imp_scope.
Notation "'WHILE' b 'DO' c 'END'" :=
  (CWhile b c) (at level 80, right associativity) : imp_scope.
Notation "'TEST' c1 'THEN' c2 'ELSE' c3 'FI'" :=
  (CIf c1 c2 c3) (at level 80, right associativity) : imp_scope.
Notation "'LOOP' a 'DO' c 'END'" :=
  (CLoop a c) (at level 70, right associativity) : imp_scope.

Reserved Notation "st '=[' c ']=>' st'"
                  (at level 40).

Inductive ceval : com -> state -> state -> Prop :=
  | E_Skip : forall st,
      st =[ SKIP ]=> st
  | E_Ass  : forall st a1 n x,
      aeval st a1 = n ->
      st =[ x ::= a1 ]=> (x !-> n ; st)
  | E_Seq : forall c1 c2 st st' st'',
      st  =[ c1 ]=> st'  ->
      st' =[ c2 ]=> st'' ->
      st  =[ c1 ;; c2 ]=> st''
  | E_IfTrue : forall st st' b c1 c2,
      beval st b = true ->
      st =[ c1 ]=> st' ->
      st =[ TEST b THEN c1 ELSE c2 FI ]=> st'
  | E_IfFalse : forall st st' b c1 c2,
      beval st b = false ->
      st =[ c2 ]=> st' ->
      st =[ TEST b THEN c1 ELSE c2 FI ]=> st'
  | E_WhileFalse : forall b st c,
      beval st b = false ->
      st =[ WHILE b DO c END ]=> st
  | E_WhileTrue : forall st st' st'' b c,
      beval st b = true ->
      st  =[ c ]=> st' ->
      st' =[ WHILE b DO c END ]=> st'' ->
      st  =[ WHILE b DO c END ]=> st''
  | E_LoopZero : forall (st:state) (a:aexp)  (c:com),
    aeval st a = 0 -> 
    st =[ LOOP a DO c END ]=> st
  | E_LoopMore : forall st st' st'' a c v,
      aeval st a = v ->
      v > 0 ->
    st =[ c ]=> st' -> 
    st' =[ LOOP (ANum (pred v)) DO c END ]=> st'' ->
    st =[ LOOP a DO c END ]=> st''

  where "st =[ c ]=> st'" := (ceval c st st').

(*
st =[ LOOP a DO c END ]=> st' iff st=[ c;c;...;c] => st'
where c is composed (eval st a) times.
*)

Example ex1: forall x c, (x) =[ LOOP (ANum 0) DO c END ]=> (x).

Proof.
  intros. apply E_LoopZero. reflexivity.
Qed.

Example ex2: (X !-> 0; empty_st) =[ LOOP (ANum 4) DO X ::= (AId X) + (ANum 1) END ]=> (X !-> 4; X !-> 3; X !-> 2; X !-> 1; X !-> 0; empty_st).

Proof.  
  repeat
   (try (eapply E_LoopMore; try reflexivity; try apply le_plus_l; try (apply E_Ass; reflexivity));  
   try (apply E_LoopZero; reflexivity)). 
 Qed. 


Example ex3: (X !-> 4; empty_st) =[ LOOP (AId X) DO X ::= (AId X) + (ANum 1) END ]=> (X !-> 8; X !-> 7; X !-> 6; X !-> 5; X !-> 4; empty_st).
Proof.
  repeat
   (try (eapply E_LoopMore; try reflexivity; try apply le_plus_l; try (apply E_Ass; reflexivity));  
   try (apply E_LoopZero; reflexivity)). 
 Qed. 

(* TODO: We should probably try to prove that our rule doesn't break the other rules, as well as its general correctness *)

Theorem ceval_deterministic: forall c st st1 st2,
     st =[ c ]=> st1  ->
     st =[ c ]=> st2 ->
     st1 = st2.
Proof.
  intros c st st1 st2 E1 E2.
  generalize dependent st2.
  induction E1;
           intros st2 E2; inversion E2; subst.
  - (* E_Skip *) reflexivity.
  - (* E_Ass *) reflexivity.
  - (* E_Seq *)
    assert (st' = st'0) as EQ1.
    { (* Proof of assertion *) apply IHE1_1; assumption. }
    subst st'0.
    apply IHE1_2. assumption.
  - (* E_IfTrue, b1 evaluates to true *)
      apply IHE1. assumption.
  - (* E_IfTrue,  b1 evaluates to false (contradiction) *)
      rewrite H in H5. discriminate H5.
  - (* E_IfFalse, b1 evaluates to true (contradiction) *)
      rewrite H in H5. discriminate H5.
  - (* E_IfFalse, b1 evaluates to false *)
      apply IHE1. assumption.
  - (* E_WhileFalse, b1 evaluates to false *)
    reflexivity.
  - (* E_WhileFalse, b1 evaluates to true (contradiction) *)
    rewrite H in H2. discriminate H2.
  - (* E_WhileTrue, b1 evaluates to false (contradiction) *)
    rewrite H in H4. discriminate H4.
  - (* E_WhileTrue, b1 evaluates to true *)
      assert (st' = st'0) as EQ1.
      { (* Proof of assertion *) apply IHE1_1; assumption. }
      subst st'0.
      apply IHE1_2. assumption.  
  - reflexivity.
  - Admitted.



(* Hoare *)

Definition Assertion := state -> Prop.

Definition assert_implies (P Q : Assertion) : Prop :=
  forall st, P st -> Q st.

Notation "P ->> Q" := (assert_implies P Q)
                      (at level 80) : hoare_spec_scope.
Open Scope hoare_spec_scope.

Notation "P <<->> Q" :=
  (P ->> Q /\ Q ->> P) (at level 80) : hoare_spec_scope.

Definition hoare_triple
           (P : Assertion) (c : com) (Q : Assertion) : Prop :=
  forall st st',
     st =[ c ]=> st'  ->
     P st  ->
     Q st'.

Notation "{{ P }}  c  {{ Q }}" :=
  (hoare_triple P c Q) (at level 90, c at next level)
  : hoare_spec_scope.


Theorem hoare_post_true : forall (P Q : Assertion) c,
  (forall st, Q st) ->
  {{P}} c {{Q}}.
Proof.
  intros P Q c H. unfold hoare_triple.
  intros st st' Heval HP.
  apply H.  Qed.

Theorem hoare_pre_false : forall (P Q : Assertion) c,
  (forall st, ~ (P st)) ->
  {{P}} c {{Q}}.
Proof.
  intros P Q c H. unfold hoare_triple.
  intros st st' Heval HP.
  unfold not in H. apply H in HP.
  inversion HP.  Qed.

Definition assn_sub X a P : Assertion :=
  fun (st : state) =>
    P (X !-> aeval st a ; st).

Notation "P [ X |-> a ]" := (assn_sub X a P)
  (at level 10, X at next level).


Theorem hoare_asgn : forall Q X a,
  {{Q [X |-> a]}} X ::= a {{Q}}.
Proof.
  unfold hoare_triple.
  intros Q X a st st' HE HQ.
  inversion HE. subst.
  unfold assn_sub in HQ. assumption.  Qed.

Theorem hoare_consequence_pre : forall (P P' Q : Assertion) c,
  {{P'}} c {{Q}} ->
  P ->> P' ->
  {{P}} c {{Q}}.
Proof.
  intros P P' Q c Hhoare Himp.
  intros st st' Hc HP. apply (Hhoare st st').
  assumption. apply Himp. assumption. Qed.

Theorem hoare_consequence_post : forall (P Q Q' : Assertion) c,
  {{P}} c {{Q'}} ->
  Q' ->> Q ->
  {{P}} c {{Q}}.
Proof.
  intros P Q Q' c Hhoare Himp.
  intros st st' Hc HP.
  apply Himp.
  apply (Hhoare st st').
  assumption. assumption. Qed.

Theorem hoare_consequence : forall (P P' Q Q' : Assertion) c,
  {{P'}} c {{Q'}} ->
  P ->> P' ->
  Q' ->> Q ->
  {{P}} c {{Q}}.
Proof.
  intros P P' Q Q' c Hht HPP' HQ'Q.
  apply hoare_consequence_pre with (P' := P').
  apply hoare_consequence_post with (Q' := Q').
  assumption. assumption. assumption.  Qed.

Theorem hoare_skip : forall P,
     {{P}} SKIP {{P}}.
Proof.
  intros P st st' H HP. inversion H. subst.
  assumption.  Qed.

Theorem hoare_seq : forall P Q R c1 c2,
     {{Q}} c2 {{R}} ->
     {{P}} c1 {{Q}} ->
     {{P}} c1;;c2 {{R}}.
Proof.
  intros P Q R c1 c2 H1 H2 st st' H12 Pre.
  inversion H12; subst.
  apply (H1 st'0 st'); try assumption.
  apply (H2 st st'0); assumption. Qed.

Definition bassn b : Assertion :=
  fun st => (beval st b = true).

Lemma bexp_eval_true : forall b st,
  beval st b = true -> (bassn b) st.
Proof.
  intros b st Hbe.
  unfold bassn. assumption.  Qed.

Lemma bexp_eval_false : forall b st,
  beval st b = false -> ~ ((bassn b) st).
Proof.
  intros b st Hbe contra.
  unfold bassn in contra.
  rewrite -> contra in Hbe. inversion Hbe.  Qed.

Theorem hoare_while : forall P b c,
  {{fun st => P st /\ bassn b st}} c {{P}} ->
  {{P}} WHILE b DO c END {{fun st => P st /\ ~ (bassn b st)}}.
Proof.
  intros P b c Hhoare st st' He HP.
  (* Like we've seen before, we need to reason by induction
     on [He], because, in the "keep looping" case, its hypotheses
     talk about the whole loop instead of just [c]. *)
  remember (WHILE b DO c END)%imp as wcom eqn:Heqwcom.
  induction He;
    try (inversion Heqwcom); subst; clear Heqwcom.
  - (* E_WhileFalse *) 
    split. assumption. apply bexp_eval_false. assumption.
  - (* E_WhileTrue *)
    apply IHHe2. reflexivity.
    apply (Hhoare st st'). assumption.
      split. assumption. apply bexp_eval_true. assumption.
Qed.

(*TODO*)


Lemma loop_skip_ANum : forall n st, 
   st =[ LOOP (ANum n) DO SKIP END ]=> st.

Proof.
  intros. induction n.
  - eapply E_LoopZero. reflexivity.
  - eapply E_LoopMore. reflexivity.
    apply gt_Sn_O. apply E_Skip.
    apply IHn.
Qed.

Lemma aexp_loop : forall c a st st',
  st =[ LOOP ANum (aeval st a) DO c END ]=> st' <-> st =[ LOOP a DO c END ]=> st'.

Proof.
  intros. split. - intros. inversion H.
  + subst. simpl in H4. eapply E_LoopZero in H4. apply H4.
  + subst. simpl in H7. simpl in H3. remember (aeval st a).
    apply Nat.eq_sym_iff in Heqn. eapply E_LoopMore in Heqn.
    * apply Heqn.
    * apply H3.
    * apply H4.
    * apply H7.
  - intros. inversion H.
    + subst. rewrite H4. eapply E_LoopZero. reflexivity.
    + subst. remember (aeval st a). eapply E_LoopMore.
      * apply Heqn.
      * rewrite <- Heqn. apply H3.
      * apply H4.
      * simpl. rewrite <- Heqn. apply H7.
Qed.

Theorem loop_skip_general :  forall (n:aexp) (st:state),
  st =[ LOOP n DO SKIP END ]=> st.

Proof.
  intros. induction n eqn:E;
  try (apply aexp_loop; apply loop_skip_ANum).
Qed.


Lemma loop : forall  (v:nat) (n:aexp) (st st':state) (c:com) , st =[ LOOP n DO c END ]=> st' ->
              aeval st n = v
              -> st =[ LOOP (ANum v) DO c END ]=> st'.

Proof.
  intros. rewrite <- H0. apply aexp_loop. apply H.
Qed. 

Example ex4 : forall P X,  {{P}} LOOP X DO SKIP END {{P}}.

Proof.
  intros P e st st' H H'. assert (st' = st).
  { eapply ceval_deterministic. apply H. apply loop_skip_general. }
  rewrite H0. apply H'.
Qed.


Lemma hoare_loop_ANum : forall P n c, 
  {{P}} c {{P}} ->
  {{P}} LOOP (ANum n) DO c END {{P}}.

Proof.
  intros. induction n. 
    + intros st st' H' H0. assert (aeval st (ANum 0) = 0). reflexivity.
    eapply E_LoopZero in H1. assert (st = st').
    eapply ceval_deterministic. apply H1. apply H'. rewrite <- H2.
    apply H0.
    + unfold hoare_triple. intros.
    unfold hoare_triple in H. unfold hoare_triple in IHn.
    remember (aeval st (ANum (S n))). 
    apply Nat.eq_sym_iff in Heqn0. inversion H0.
    * subst. apply H1.
    * subst. simpl in H9. eapply IHn. apply H9. eapply H.
    { apply H6. }
    { apply H1. }
Qed.

Theorem hoare_loop_simple : forall P e c,
  {{P}} c {{P}} ->
  {{P}} LOOP e DO c END {{P}}.

(*TODO automate this proof, too repetitive*)

Proof. 
  intros.
  induction e.
  - apply hoare_loop_ANum. apply H.
  - unfold hoare_triple. intros. apply aexp_loop in H0.
    remember (aeval st (AId x)). eapply hoare_loop_ANum. apply H.
    apply H0. apply H1.
  - unfold hoare_triple. intros. apply aexp_loop in H0.
    remember (aeval st (e1 + e2)). eapply hoare_loop_ANum. apply H.
    apply H0. apply H1.
  - unfold hoare_triple. intros. apply aexp_loop in H0.
    remember (aeval st (e1 - e2)). eapply hoare_loop_ANum. apply H.
    apply H0. apply H1.
  - unfold hoare_triple. intros. apply aexp_loop in H0.
    remember (aeval st (e1 * e2)). eapply hoare_loop_ANum. apply H.
    apply H0. apply H1. 
Qed.


Example ex5 : forall P X,  {{P}} LOOP X DO SKIP END {{P}}.

Proof.
  intros. apply hoare_loop_simple. apply hoare_skip.
Qed.

(*
 forall z. {{P /\ t=z}} c {{P /\ t=z-1}}.
---------------------------------
 {{P /\ t=e }} LOOP e DO c END {{P} /\ t=0 }.
*)

(*
Example ex6 : forall X n (st st':state) ,  {{fun st => X = n /\ st Z = 0}} LOOP (X) DO Z ::= (AId Z) + (ANum 1) END {{fun st' => X = n /\ st Z = aeval st n}}.
*)

(*  
Theorem hoare_loop : forall P e c t,
  (forall z, {{fun st => P st /\ (st t) = z}} c;; t ::= (AId t) - (ANum 1) {{fun st => P st /\ st t = (z - 1)}}) ->
  {{fun st => P st /\ st t = e}} LOOP (ANum e) DO c END {{fun st => P st /\ (st t) = 0}}.*)


Theorem hoare_loop : forall P e c t r,
  (forall z, {{fun st => P st /\ (st t) = z}} c;; t ::= (AId t) - (ANum 1) {{fun st' => P st' /\ st' t = (z - 1)}}) ->
  {{fun st => P st /\ (aeval st e) = r}} LOOP e DO c END {{fun st' => P st' /\ (aeval st' e) = 0}}.

Proof. 
  intros. unfold hoare_triple in H. unfold hoare_triple. intros.
inversion H0.
  - subst. rewrite H6 in H1. split. apply H1. destruct H1. rewrite H2. rewrite <- H2. auto.
  - subst. 







